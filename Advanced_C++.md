# Advanced_c++

## CONST

- A compile time constraint that an object can not be modified

```cpp
const int i = 9;
// i = 10 // gives error

const int * p1 = &i //data is const, pointer is not

int * const p2; //data is not, pointer is const

const int * const p3; //both data and pointer are const
```

### For ease of use

```cpp
// If const is on the left side of the *, data is const
// If const is on the right side of the *, pointer is const
```

### Casting

```cpp
int const i = 9;

// From const to non-const
const_cast<int&> (i) = 6;

// From non-const to const
static_cast<const int&> (i);
```

- Not Recommended as it breaks someone's promise not to change a variable

### Observations

- You can't assign a refference(pointer) to const if it's not of the same type of const
- The other way around works

```cpp
int const arg = 8;
int * ptr = &arg; // doesn't work 

int arg = 8;
int const * ptr = &arg; //works fine
```

### Const Benefits

1. Guard against inadvertent wriet to the variable.
2. Self documenting - increases readability
3. Enable compiler to do more optimization, making code tighter.
4. **const** means the variable can be put in ROM - useful for embbeded systems

## CONST and FUNCTIONS

- usage of const in functions

### Const as Paramenters

```cpp
void func(int const& arg); // used in order to not modify the original variable
void func(int const arg); // doesn't modify the copy of the original but doesn't bring much to the table
```

### Const as return values

```cpp
// return by const value
// doesn't make much sense as it is not important for a copy to remain the same
const std::string func();
// return by reference
const std::string& func();
```

### const function

```cpp
// Will not change any of the member variables in an object
void func() const;
```

- this type of function will be able to call only const type function even though those function might not change any variables in the object

### const function 2

```cpp
// This function will be called when the object is initalized as const
void func() const { std::cout << "const"; };
// This function will be called if the member is not const
void func() const { std::cout << "non-const"; };
```

## COMPILER GENERATED FUNCTIONS

- Compiler writes 4 functions if they are not explicitly defined/declared:
    1. Copy constructor
    2. Copy Assignment Operator
    3. Destructor
    4. Default Constructor(Only if there is no constructor declared)

- Prezenting:

```cpp
class Dog {

};
//They are echivalent
class Dog {
    public:
        //Member by member initialization
        Dog(const dog& name_not_matter) { ... }; 
        
        //Member by member copying
        Dog& operator=(const Dog& name_not_matter) { ... };
        
        //1. Call base class's default constructor
        //2. Call data member's default constructor
        Dog() { ... }; 

        //1. Call base class's destructor
        //2. Call data member's destructor
        ~Dog() { ... };  
};
```

- They are generated by compiler only if they are used

### C++ 11 new way to define default constructor

```cpp
class Dog {
    public:
        Dog() = default();
        Dog(std::string name_not_matter) { ... };
};
```

- Used to define the default constructor when there are other constructors defined already

## DISALLOW FUNCTIONS

- Compiler Generated functions aren't always useful and sometimes even dangerous (Copy Assignment, Copy Constructor)

### Default Constructor

- As long as you generate a constructor the default one will not be generated anymore

```cpp
class OpenFile(){
    public:
        OpenFile(std:: filename_not_matter) { std::cout << "Open a file " << std::endl; };
}
```

### Disable any function

```cpp
class OpenFile(){
    public:
        // Disallow the copy constructor for C++11
        OpenFile(OpenFile& class_not_matter) = delete;

        // Disallow for C++03
        // Make the copy constructor private
    private:
        OpenFile(OpenFile& class_not_matter);
}
```

### Destructor Case

```cpp
class OpenFile(){
    public:
        OpenFile(std:: filename_not_matter) { std::cout << "Open a file " << std::endl; };
        void destroyMe() { delete this; };
    private:
        ~OpenFile(){std::cout << "Object Destroyed " << std::endl;};
}

int main(){
    OpenFile* f = new OpenFile(std::string("name_for_file"));
    f->destroyMe;
}
```

- This is useful in embbeded programming were stack is small and errors like stack overflow occur

### Summary

1. C++11: ```f() = delete```
2. C++03: declare the function to be private, and not define it
3. Private Destructor: Stay out of stack

## VIRTUAL DESTRUCTORS IN POLYMORTHIC BASE CLASSES

### Example of usage

- Polymorthic way: ```Dog* dog = new BrownDog();```

```cpp
class Dog {
    public:
    ~Dog(){std::cout << "Dog Destroyed\n";}
};
class BrownDog : public Dog {
    public:
    ~BrownDog(){std::cout << "BrownDog Destroyed";};
}
// When deleting object only Base Class Pointer gets called
```

```cpp
class Dog {
    public:
    virtual ~Dog(){std::cout << "Dog Destroyed\n";}
};
class BrownDog : public Dog {
    public:
    ~BrownDog(){std::cout << "BrownDog Destroyed";};
}
// When deleting object both destructors get called
```

- Virtual keyword ensures that destructors are invoced correctly

### Other way to solve the problem

- using ```shared_ptr<class_name>```

```cpp
shared_ptr<base_class_name> give_me_a_dog(){
    return shared_ptr<derived_class_name>(new derived_class_name());
}
// ...
shared_ptr<base_class_name> = give_me_a_dog();
```

- This only works with shared_ptr(not unique_ptr)
- All classes in STL have no virtual destructor, so programmers should be careful when inheriting from them

## Exception in Destructors

- Preventing Exceptions from leaving Destructors

```cpp
class Dog {
    public:
    std::string name;
    Dog(const std::string &name){
        this->name = name;
        std::cout << "A new dog named " << name << " was created.\n";
    }
    ~Dog(){
        std::cout << "The dog named " << name << " was destroyed.\n";
        throw 20;
    }
    void bark(){
        std::cout << name << " says: Woof!\n";
    }
};
int main(){
    try{
        Dog dog1("dog1");
        Dog dog2("dog2");
        dog1.bark();
        dog2.bark();
    } catch(int err){
        std::cerr << "An error occurred: " << err << std::endl;
    }

    return 0;
}
```

- By throwing error inside a destructor, there will be 2 throw at the same time, and it will block the catch block

### Solution 1

- Destructor Swallow the exception

```cpp
~Dog(){
    try{
        //code
        throw '1';
    } catch(int err){
        //catch err
    } // ... another catches
}
```

### Solution 2

- Moving the exception-prone code to different function

```cpp
class Dog {
    public:
    std::string name;
    Dog(const std::string &name){
        this->name = name;
        std::cout << "A new dog named " << name << " was created.\n";
    }
    ~Dog(){
        std::cout << "The dog named " << name << " was destroyed.\n";
    }
    void prepareToDestroy(){...; throw 'e';}
    void bark(){
        std::cout << name << " says: Woof!\n";
    }
};
```

- There is gone be one additional api

## VIRTUAL FUNCTIONS INSIDE CONSTRUCTOR AND DESTRUCTOR

```cpp
class Dog {
    public:
    Dog(){
        std::cout << "Dog created" << std::endl; 
    }
    virtual void bark(){
        std::cout << "Dog says Woof!" << std::endl;
    }
    void seeCat(){
        bark();
    }
};
class BrownDog : public Dog{
    public:
    BrownDog(){
        std::cout << "Brown Dog created" << std::endl;
    }
    virtual void bark(){
        std::cout << "Brown Dog says Bark!" << std::endl;
    }
};

int main(){
    BrownDog dog;
    dog.seeCat();
    return 0;
}
// OUTPUT:
// Dog created
// Brown Dog created
// Brown Dog says Bark!
```

- Virtual status is inherited but it is good for practice to write it in order to make it more explicit

### Scenario where this idea doens't work

- Virtual function is called inside the base constructor

```cpp
class Dog {
    public:
    Dog(){
        std::cout << "Dog created" << std::endl; 
        bark();
    }
    virtual void bark(){
        std::cout << "Dog says Woof!" << std::endl;
    }
    void seeCat(){
        bark();
    }
};
```

- In this example the method called is that of the base class as the derived one isn't created yet.
- We should avoid calling virtual function inside constructor
- Works the same way with Destructor, as it is not good to call the fuction of something that is already destroyed

## Assigning to Self in Assignment Operator

- Handling self_assignment in operator=
- Operator Overload: exploite people's intuition and reduce their learning curve

```cpp
Dog dd;
dd = dd; // self_assignment that looks silly

dogs[i] = dog[j]; // self_assignment that might happen
```

### Implementing Assignment Operator

#### Presenting Problem

```cpp
class collar;
class dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        delete pcollar;
        pcollar = new collar(the_other_dog->pcollar);
        return *this;
    }
}
// Looks normal if we are not assigning the same object to itself
```

- when ```delete pcollar```, we are deleting pcollar of the same object, which is the rvalue in this case
- when ```new collar(the_other_dog->pcollar)``` we are passing a deleted parameter

#### Solution1

```cpp
class collar;
class dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        if(this == &the_other_dog) return *this;
        // or 
        // if(*this == the_other_dog) return *this;

        delete pcollar;
        pcollar = new collar(the_other_dog->pcollar);
        return *this;
    }
}
```

- Other problem that might occur is the ```new``` operator throws an exception
- The complete solution looks like this:

```cpp
class collar;
class dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        if(this == &the_other_dog) return *this;
        // or 
        // if(*this == the_other_dog) return *this;

        collar *ptrOriginal = pCollar;
        pcollar = new collar(the_other_dog->pcollar);
        delete pOriginal;
        return *this;
    }
}
```

#### Solution2

- Delegation
- Member by member copying of collars ot
- call collar's operator=

```cpp
class Dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        *pcollar = the_other_dog->pCollar;

        return *this;
    }
};
```

## SPECIAL CODING TEHNIQUE "Resource Acquisition is Initialization (RAII)"

- Use objects to manage resources:
  1. memory
  2. hardware device
  3. network handle

```cpp
Mutex_t mu = MUTEX_INITIALIZER;

void functionA(){
    Mutex_lock(&mu);
    ... // do things
    Mutex_unlock($mu); //Will this line always be executed?
}
```

### Problem

- By doing thing we might return out of function prematurely and leave the mutex forever locked

### Solution

```cpp
class Lock {
    private:
        Mutext_t* m_pm;
    public:
        explicit Lock(Mutext_t *pm) {
            Mutex_lock(pm); m_pm = pm;
        }
        ~Lock() {
            Mutex_unlock(m_pm);
        }
};
void function(){
    Lock myLock(&mu);
    ... // Do things
}
```

- This way the Mutex will always be released when mylock is destroyed from stack
- The only code that can be guaranteed to be executed after exception is thrown are destructors of the objects residing on the stack.
- Resource management therefore needs to be tied to the lifespan of suitable objects in order to gain automatic deallocation and reclamation.

### Note 1

- Use of ```tr1::shared_ptr```

```cpp
int function(){
    std::tr1::shared_ptr<dog> pd(new dog());
    ...
}
```

- The dog is destructed when pd goes out of scope
- No more pointer points to pd

## STRUCT vs. CLASS

### **Struct** - Small passive objects that carry public data and have no or few basic member functions

- Data container

  ```cpp
  struct Person_t{
    std::string name; // public  
  };
  ```

### **Class** - Bigger active objects that carry private data, interfaced through public member functions

- Complex data structures

  ```cpp
  class Person_t{
    std::string name; // private
  };
  ```

### Summary_

1. Use **struct** for passive objects with public data, use classes for active objects with private data
2. Use setter/getter to access class's data
3. Avoid making setter/getter if possible

## Static Initialization Fiasco

- A subtle problem that can crash the program

### Problem_

- Considering 2 header files with one class each
- One class' constructor calls a function of another class
- This might crash the program as there is a 50% change the object called was initialized

- This is solved through **Singleton**

## SINGLETONS

- This is a design pattern that ensures a class has only one instance and provides a global point of access to that instance. This is commonly used when exactly one object is needed to coordinate actions across system

### Key Features of Singleton Pattern

1. Single Instance: The class restricts itself to a single instance, prevnting the creation of aditional instances
2. Global Access: The single instance is accessible from anywhere within the program
3. Lazy Initialization: The instance is only created when it's needed

### Common Use Cases

- Configuration Managers: To manage application settings globally
- Logging: To have a single logging throughout the application
- Resource Management: For managing connections (like database connections) where only one connection manager is required

### Implementation of Singleton in C++

```cpp
#include <iostream>
using namespace std;

class Singleton {
private:
    // Private constructor prevents external instantiation
    Singleton() {
        cout << "Singleton instance created\n";
    }
    
    // Private static instance of the same class
    static Singleton* instance;

public:
    // Delete copy constructor and assignment operator
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // Static method to get the singleton instance
    static Singleton* getInstance() {
        if (instance == nullptr) {  // Lazy initialization
            instance = new Singleton();
        }
        return instance;
    }

    void showMessage() const {
        cout << "Hello from the Singleton instance!\n";
    }
};

// Initialize the static member
Singleton* Singleton::instance = nullptr;

int main() {
    // Get the singleton instance and call a method
    Singleton* s = Singleton::getInstance();
    s->showMessage();

    // Attempting to get another instance will return the same instance
    Singleton* s2 = Singleton::getInstance();
    s2->showMessage();

    return 0;
}

```

### Explanation

- **Private Constructor** - The constructor is private, which prevents objects from being created directly with the new operator
- **Static Instance** - A static member ```instance``` holds the single instance of the class
- **Lazy initialization** - The ```getInstance()``` method checks if the instance is ```nullptr```. If it is, it creates a new instance. Otherwise, it returns the existing instance.
- **Deleted Copy Constructor and Assignment Operator** - These prevent copying or assigning instances of the singleton, ensuring only one instance exists.

### Thread-Safety Considerations

- If multiple threads call ```getInstance()``` simultaneously, you should make it thread safe to avoid creating multiple instances. In C++11 and later, you can use:

```cpp
static Singleton& getInstance(){
    static Singleton instance;
    return instance;
}
```
