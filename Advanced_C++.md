# Advanced_c++

## CONST

- A compile time constraint that an object can not be modified

```cpp
const int i = 9;
// i = 10 // gives error

const int * p1 = &i //data is const, pointer is not

int * const p2; //data is not, pointer is const

const int * const p3; //both data and pointer are const
```

### For ease of use

```cpp
// If const is on the left side of the *, data is const
// If const is on the right side of the *, pointer is const
```

### Casting

```cpp
int const i = 9;

// From const to non-const
const_cast<int&> (i) = 6;

// From non-const to const
static_cast<const int&> (i);
```

- Not Recommended as it breaks someone's promise not to change a variable

### Observations

- You can't assign a refference(pointer) to const if it's not of the same type of const
- The other way around works

```cpp
int const arg = 8;
int * ptr = &arg; // doesn't work 

int arg = 8;
int const * ptr = &arg; //works fine
```

### Const Benefits

1. Guard against inadvertent wriet to the variable.
2. Self documenting - increases readability
3. Enable compiler to do more optimization, making code tighter.
4. **const** means the variable can be put in ROM - useful for embbeded systems

## CONST and FUNCTIONS

- usage of const in functions

### Const as Paramenters

```cpp
void func(int const& arg); // used in order to not modify the original variable
void func(int const arg); // doesn't modify the copy of the original but doesn't bring much to the table
```

### Const as return values

```cpp
// return by const value
// doesn't make much sense as it is not important for a copy to remain the same
const std::string func();
// return by reference
const std::string& func();
```

### const function

```cpp
// Will not change any of the member variables in an object
void func() const;
```

- this type of function will be able to call only const type function even though those function might not change any variables in the object

### const function 2

```cpp
// This function will be called when the object is initalized as const
void func() const { std::cout << "const"; };
// This function will be called if the member is not const
void func() const { std::cout << "non-const"; };
```

## COMPILER GENERATED FUNCTIONS

- Compiler writes 4 functions if they are not explicitly defined/declared:
    1. Copy constructor
    2. Copy Assignment Operator
    3. Destructor
    4. Default Constructor(Only if there is no constructor declared)

- Prezenting:

```cpp
class Dog {

};
//They are echivalent
class Dog {
    public:
        //Member by member initialization
        Dog(const dog& name_not_matter) { ... }; 
        
        //Member by member copying
        Dog& operator=(const Dog& name_not_matter) { ... };
        
        //1. Call base class's default constructor
        //2. Call data member's default constructor
        Dog() { ... }; 

        //1. Call base class's destructor
        //2. Call data member's destructor
        ~Dog() { ... };  
};
```

- They are generated by compiler only if they are used

### C++ 11 new way to define default constructor

```cpp
class Dog {
    public:
        Dog() = default();
        Dog(std::string name_not_matter) { ... };
};
```

- Used to define the default constructor when there are other constructors defined already

## DISALLOW FUNCTIONS

- Compiler Generated functions aren't always useful and sometimes even dangerous (Copy Assignment, Copy Constructor)

### Default Constructor

- As long as you generate a constructor the default one will not be generated anymore

```cpp
class OpenFile(){
    public:
        OpenFile(std:: filename_not_matter) { std::cout << "Open a file " << std::endl; };
}
```

### Disable any function

```cpp
class OpenFile(){
    public:
        // Disallow the copy constructor for C++11
        OpenFile(OpenFile& class_not_matter) = delete;

        // Disallow for C++03
        // Make the copy constructor private
    private:
        OpenFile(OpenFile& class_not_matter);
}
```

### Destructor Case

```cpp
class OpenFile(){
    public:
        OpenFile(std:: filename_not_matter) { std::cout << "Open a file " << std::endl; };
        void destroyMe() { delete this; };
    private:
        ~OpenFile(){std::cout << "Object Destroyed " << std::endl;};
}

int main(){
    OpenFile* f = new OpenFile(std::string("name_for_file"));
    f->destroyMe;
}
```

- This is useful in embbeded programming were stack is small and errors like stack overflow occur

### Summary

1. C++11: ```f() = delete```
2. C++03: declare the function to be private, and not define it
3. Private Destructor: Stay out of stack

## VIRTUAL DESTRUCTORS IN POLYMORTHIC BASE CLASSES

### Example of usage

- Polymorthic way: ```Dog* dog = new BrownDog();```

```cpp
class Dog {
    public:
    ~Dog(){std::cout << "Dog Destroyed\n";}
};
class BrownDog : public Dog {
    public:
    ~BrownDog(){std::cout << "BrownDog Destroyed";};
}
// When deleting object only Base Class Pointer gets called
```

```cpp
class Dog {
    public:
    virtual ~Dog(){std::cout << "Dog Destroyed\n";}
};
class BrownDog : public Dog {
    public:
    ~BrownDog(){std::cout << "BrownDog Destroyed";};
}
// When deleting object both destructors get called
```

- Virtual keyword ensures that destructors are invoced correctly

### Other way to solve the problem

- using ```shared_ptr<class_name>```

```cpp
shared_ptr<base_class_name> give_me_a_dog(){
    return shared_ptr<derived_class_name>(new derived_class_name());
}
// ...
shared_ptr<base_class_name> = give_me_a_dog();
```

- This only works with shared_ptr(not unique_ptr)
- All classes in STL have no virtual destructor, so programmers should be careful when inheriting from them

## Exception in Destructors

- Preventing Exceptions from leaving Destructors

```cpp
class Dog {
    public:
    std::string name;
    Dog(const std::string &name){
        this->name = name;
        std::cout << "A new dog named " << name << " was created.\n";
    }
    ~Dog(){
        std::cout << "The dog named " << name << " was destroyed.\n";
        throw 20;
    }
    void bark(){
        std::cout << name << " says: Woof!\n";
    }
};
int main(){
    try{
        Dog dog1("dog1");
        Dog dog2("dog2");
        dog1.bark();
        dog2.bark();
    } catch(int err){
        std::cerr << "An error occurred: " << err << std::endl;
    }

    return 0;
}
```

- By throwing error inside a destructor, there will be 2 throw at the same time, and it will block the catch block

### Solution 1

- Destructor Swallow the exception

```cpp
~Dog(){
    try{
        //code
        throw '1';
    } catch(int err){
        //catch err
    } // ... another catches
}
```

### Solution 2

- Moving the exception-prone code to different function

```cpp
class Dog {
    public:
    std::string name;
    Dog(const std::string &name){
        this->name = name;
        std::cout << "A new dog named " << name << " was created.\n";
    }
    ~Dog(){
        std::cout << "The dog named " << name << " was destroyed.\n";
    }
    void prepareToDestroy(){...; throw 'e';}
    void bark(){
        std::cout << name << " says: Woof!\n";
    }
};
```

- There is gone be one additional api

## VIRTUAL FUNCTIONS INSIDE CONSTRUCTOR AND DESTRUCTOR

```cpp
class Dog {
    public:
    Dog(){
        std::cout << "Dog created" << std::endl; 
    }
    virtual void bark(){
        std::cout << "Dog says Woof!" << std::endl;
    }
    void seeCat(){
        bark();
    }
};
class BrownDog : public Dog{
    public:
    BrownDog(){
        std::cout << "Brown Dog created" << std::endl;
    }
    virtual void bark(){
        std::cout << "Brown Dog says Bark!" << std::endl;
    }
};

int main(){
    BrownDog dog;
    dog.seeCat();
    return 0;
}
// OUTPUT:
// Dog created
// Brown Dog created
// Brown Dog says Bark!
```

- Virtual status is inherited but it is good for practice to write it in order to make it more explicit

### Scenario where this idea doens't work

- Virtual function is called inside the base constructor

```cpp
class Dog {
    public:
    Dog(){
        std::cout << "Dog created" << std::endl; 
        bark();
    }
    virtual void bark(){
        std::cout << "Dog says Woof!" << std::endl;
    }
    void seeCat(){
        bark();
    }
};
```

- In this example the method called is that of the base class as the derived one isn't created yet.
- We should avoid calling virtual function inside constructor
- Works the same way with Destructor, as it is not good to call the fuction of something that is already destroyed

## Assigning to Self in Assignment Operator

- Handling self_assignment in operator=
- Operator Overload: exploite people's intuition and reduce their learning curve

```cpp
Dog dd;
dd = dd; // self_assignment that looks silly

dogs[i] = dog[j]; // self_assignment that might happen
```

### Implementing Assignment Operator

#### Presenting Problem

```cpp
class collar;
class dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        delete pcollar;
        pcollar = new collar(the_other_dog->pcollar);
        return *this;
    }
}
// Looks normal if we are not assigning the same object to itself
```

- when ```delete pcollar```, we are deleting pcollar of the same object, which is the rvalue in this case
- when ```new collar(the_other_dog->pcollar)``` we are passing a deleted parameter

#### Solution1

```cpp
class collar;
class dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        if(this == &the_other_dog) return *this;
        // or 
        // if(*this == the_other_dog) return *this;

        delete pcollar;
        pcollar = new collar(the_other_dog->pcollar);
        return *this;
    }
}
```

- Other problem that might occur is the ```new``` operator throws an exception
- The complete solution looks like this:

```cpp
class collar;
class dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        if(this == &the_other_dog) return *this;
        // or 
        // if(*this == the_other_dog) return *this;

        collar *ptrOriginal = pCollar;
        pcollar = new collar(the_other_dog->pcollar);
        delete pOriginal;
        return *this;
    }
}
```

#### Solution2

- Delegation
- Member by member copying of collars ot
- call collar's operator=

```cpp
class Dog{
    collar* pcollar;
    dog& operator=(const dog& the_other_dog){
        *pcollar = the_other_dog->pCollar;

        return *this;
    }
};
```

## SPECIAL CODING TEHNIQUE "Resource Acquisition is Initialization (RAII)"

- Use objects to manage resources:
  1. memory
  2. hardware device
  3. network handle

```cpp
Mutex_t mu = MUTEX_INITIALIZER;

void functionA(){
    Mutex_lock(&mu);
    ... // do things
    Mutex_unlock($mu); //Will this line always be executed?
}
```

### Problem

- By doing thing we might return out of function prematurely and leave the mutex forever locked

### Solution

```cpp
class Lock {
    private:
        Mutext_t* m_pm;
    public:
        explicit Lock(Mutext_t *pm) {
            Mutex_lock(pm); m_pm = pm;
        }
        ~Lock() {
            Mutex_unlock(m_pm);
        }
};
void function(){
    Lock myLock(&mu);
    ... // Do things
}
```

- This way the Mutex will always be released when mylock is destroyed from stack
- The only code that can be guaranteed to be executed after exception is thrown are destructors of the objects residing on the stack.
- Resource management therefore needs to be tied to the lifespan of suitable objects in order to gain automatic deallocation and reclamation.

### Note 1

- Use of ```tr1::shared_ptr```

```cpp
int function(){
    std::tr1::shared_ptr<dog> pd(new dog());
    ...
}
```

- The dog is destructed when pd goes out of scope
- No more pointer points to pd

## STRUCT vs. CLASS

### **Struct** - Small passive objects that carry public data and have no or few basic member functions

- Data container

  ```cpp
  struct Person_t{
    std::string name; // public  
  };
  ```

### **Class** - Bigger active objects that carry private data, interfaced through public member functions

- Complex data structures

  ```cpp
  class Person_t{
    std::string name; // private
  };
  ```

### Summary_

1. Use **struct** for passive objects with public data, use classes for active objects with private data
2. Use setter/getter to access class's data
3. Avoid making setter/getter if possible

## Static Initialization Fiasco

- A subtle problem that can crash the program

### Problem_

- Considering 2 header files with one class each
- One class' constructor calls a function of another class
- This might crash the program as there is a 50% change the object called was initialized

- This is solved through **Singleton**

## SINGLETONS

- This is a design pattern that ensures a class has only one instance and provides a global point of access to that instance. This is commonly used when exactly one object is needed to coordinate actions across system

### Key Features of Singleton Pattern

1. Single Instance: The class restricts itself to a single instance, prevnting the creation of aditional instances
2. Global Access: The single instance is accessible from anywhere within the program
3. Lazy Initialization: The instance is only created when it's needed

### Common Use Cases

- Configuration Managers: To manage application settings globally
- Logging: To have a single logging throughout the application
- Resource Management: For managing connections (like database connections) where only one connection manager is required

### Implementation of Singleton in C++

```cpp
#include <iostream>
using namespace std;

class Singleton {
private:
    // Private constructor prevents external instantiation
    Singleton() {
        cout << "Singleton instance created\n";
    }
    
    // Private static instance of the same class
    static Singleton* instance;

public:
    // Delete copy constructor and assignment operator
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // Static method to get the singleton instance
    static Singleton* getInstance() {
        if (instance == nullptr) {  // Lazy initialization
            instance = new Singleton();
        }
        return instance;
    }

    void showMessage() const {
        cout << "Hello from the Singleton instance!\n";
    }
};

// Initialize the static member
Singleton* Singleton::instance = nullptr;

int main() {
    // Get the singleton instance and call a method
    Singleton* s = Singleton::getInstance();
    s->showMessage();

    // Attempting to get another instance will return the same instance
    Singleton* s2 = Singleton::getInstance();
    s2->showMessage();

    return 0;
}

```

### Explanation

- **Private Constructor** - The constructor is private, which prevents objects from being created directly with the new operator
- **Static Instance** - A static member ```instance``` holds the single instance of the class
- **Lazy initialization** - The ```getInstance()``` method checks if the instance is ```nullptr```. If it is, it creates a new instance. Otherwise, it returns the existing instance.
- **Deleted Copy Constructor and Assignment Operator** - These prevent copying or assigning instances of the singleton, ensuring only one instance exists.

### Thread-Safety Considerations

- If multiple threads call ```getInstance()``` simultaneously, you should make it thread safe to avoid creating multiple instances. In C++11 and later, you can use:

```cpp
static Singleton& getInstance(){
    static Singleton instance;
    return instance;
}
```

## Parantheses and Curly braces for std::initializer_list

### Parantheses ```()```

- **Direct Initialization** - Parentheses are used for *direct initialization*, which resembles a function call.
- **Narrowing Conversions Allowed** - If you use parentheses, narrowing conversions (like converting a ```double``` to an ```int```) are allowed.
- **Ambiguity** - In some cases, especially with single-element initializations, parentheses can be ambiguous (e.g., ```std::vector<int> v(10, 5);``` is a vector of ten elements with each initialized to 5, whereas ```std::vector<int> v{10, 5};``` would initialize a vector with two elements: 10 and 5).

```cpp
int x(5);      // Initializes x to 5
double y(3.14); // Direct initialization of y with 3.14
```

### Curly Braces ```{}```

- **Uniform Initialization (Brace Initialization)** - Introduced in C++11, brace initialization enforces *uniform initialization* and is preferred as it avoids ambiguity.
- **No Narrowing Conversions** - With curly braces, narrowing conversions are not allowed. For example, trying to initialize an ```int``` with a ```double``` using ```{}``` will cause a compile-time error.
- **Aggregate Initialization** - For structs, arrays, or classes without constructors, ```{}``` will aggregate-initialize the members directly.
- **```std::initializer_list```** - For standard library containers (e.g., ```std::vector```), ```{}``` may use an ```initializer_list``` constructor if available.

```cpp
int x{5};       // Initializes x to 5 (uniform initialization)
int y{3.14};    // Error: narrowing conversion
std::vector<int> v{1, 2, 3}; // Initializes a vector with elements 1, 2, 3
```

### Summary of Paranthesies and Curly Braces

- **()** - Direct initialization, allows narrowing conversions, can be ambiguous in some contexts.
- **{}** - Uniform initialization, disallows narrowing conversions, preferred for initializing containers and aggregate types.

## Composition and Aggregation

| Aspect | Composition | Aggregation |
|-|-|-|
| Ownership | Strong (the "whole" owns the "part") | Weak (the "whole" holds a reference to the "part") |
| Lifetime | The "part" depends on the "whole" | The "part" is independent of the "whole" |
| Example | Car and Engine (if Car dies, Engine dies) | Library and Book (books can exist without Library) |

### Composition

- Composition is a strong form of association where one object (the "whole") owns another object (the "part") and is responsible for its lifespan.

```cpp
class Engine {
public:
    Engine() { /* initialize engine */ }
    // Engine-specific functionality
};

class Car {
private:
    Engine engine; // Engine is part of Car (composition)
public:
    Car() : engine() { /* initialize car */ }
    // Car-specific functionality
};
```

### Aggregation

- Aggregation is a weaker association than composition. It represents a "has-a" relationship where the "whole" can access the "part," but it does not own it.

```cpp
class Book {
public:
    Book() { /* initialize book */ }
    // Book-specific functionality
};

class Library {
private:
    std::vector<Book*> books; // Aggregation, Library doesn't own the books
public:
    void addBook(Book* book) {
        books.push_back(book);
    }
    // Library-specific functionality
};
```

## Pointer to Implementation in Classes

- Design pattern in C++ "PImpl"
- Used to separate the interface and implementation details o a class

### How it works

1. **Define the Interface** - In the header file, you declare your class with only the public methods and a private pointer to the implementation (often a ```std::unique_ptr``` or raw pointer).
2. **Implement the Details** - In the ```.cpp``` file, you define the actual data members and private methods in a separate ```Impl``` struct or class.
3. **Encapsulate with a Pointer** - The class in the header file only needs to manage a pointer to the ```Impl``` class and define methods that forward calls to ```Impl``` methods.

### Example

```cpp
// MyClass.h
#include <memory>

class MyClass {
public:
    MyClass();
    ~MyClass();

    void someMethod();
    // other public methods

private:
    // Forward declare the implementation class and use a pointer
    struct Impl;
    std::unique_ptr<Impl> pImpl;
};
```

```cpp
// MyClass.cpp
#include "MyClass.h"

// Define the hidden implementation
struct MyClass::Impl {
    void someMethodImpl() {
        // Do something meaningful here
    }
};

MyClass::MyClass() : pImpl(std::make_unique<Impl>()) {}

MyClass::~MyClass() = default;

void MyClass::someMethod() {
    pImpl->someMethodImpl();  // Forward to the actual implementation
}
```

### Advantages

- **Improves Encapsulation** - The implementation details are hidden from users of the class, so they can't directly access internal data.
- **Reduces Compile-Time Dependencies** - Changes to private members in the implementation won’t require recompilation of the header, which speeds up compilation time.
- **Binary Compatibility** - Since clients only depend on the interface, you can change the implementation in binary libraries without breaking clients.

### Disadvantages

- **Overhead** - Using a pointer introduces a level of indirection, which has a minor performance cost, though this is usually negligible.
- **Complexity** - This pattern introduces more files and indirection, which can complicate the code structure.

### When to use Pimpl?

- You want to hide complex implementation details from the interface.
- You want to reduce compile-time dependencies and improve encapsulation.
- You’re developing a stable API, and you expect to frequently change implementation details without impacting users.

## ```STATIC```

### Outside Classes

1. Static Variables in GLobal Scopes

    - A static variable defined outside of any function or class in a ```.cpp``` file has file scope (internal linkage). This variable is limited to the file it’s defined in, meaning it cannot be accessed from other files in the project. For example:

    ```cpp
    // file1.cpp
    #include <iostream>

    static int counter = 0;  // Only accessible in file1.cpp

    void incrementCounter() {
        ++counter;
        std::cout << "Counter: " << counter << std::endl;
    }
    ```

    - If you try to use ```counter``` in another file, it will not be visible, providing a way to limit the scope of variables to individual files.

2. Static Functions

    - Similarly, static functions defined in the global scope are only visible within the file they are defined in. This can be useful for helper functions that should not be accessible from other files.

    ```cpp
    // file1.cpp
    static void helperFunction() {
        std::cout << "This is a static helper function" << std::endl;
    }
    ```

    - In this example, helperFunction can only be called within file1.cpp. If you try to call it from another file, the linker will not recognize it, keeping the function private to its file.

#### Importance of static outside classes

- **Encapsulation** - By marking variables and functions static, you keep them private to the file, preventing unintended access from other parts of the code.
- **Avoid Name Conflicts** - In large projects, many files might define functions or variables with the same name. static prevents name conflicts by ensuring that a name in one file doesn’t clash with a name in another file.

### Inside Classes

1. Static Member Variables

    - A **static member variable** is shared among all instances of the class. Unlike regular member variables, which are specific to each instance, a static member variable has a single memory location shared by all objects of the class.

    ```cpp
    #include <iostream>

    class Counter {
    public:
        static int count;  // Declaration of a static member variable

        Counter() {
            ++count;
        }

        static void showCount() {  // Static member function
            std::cout << "Current count: " << count << std::endl;
        }
    };

    // Definition and initialization of the static member variable
    int Counter::count = 0;

    int main() {
        Counter a;
        Counter b;
        Counter::showCount();  // Accessing static function

        return 0;
    }
    ```

    - **Static Member Declaration** - static int count; declares a static variable count in the class. This variable will be shared by all instances of Counter.
    - **Definition and Initialization** - int Counter::count = 0; defines the static variable outside the class, as it is not tied to a particular object.
    - **Usage** Since count is shared, each new Counter object increments the same count. The function showCount can access count without requiring an instance.

2. Static Member Functions

- A **static member function** does not have access to ```this```, meaning it can’t access non-static member variables or functions. It can, however, access static member variables and other static member functions.

```cpp
Counter::showCount();  // Access static function directly through the class
```

#### Key Points of ```static``` inside classes

- **Accessing Static Members** - You can access static member variables and functions using the class name (e.g., Counter::count) or through an object instance, though using the class name is more typical.
- **Single Storage** - There is only one copy of each static member variable, regardless of how many objects of the class exist.
- **No this Pointer** - Static member functions don’t operate on specific instances, so they don’t have access to the this pointer.

#### Use cases for Static Members Inside Classes

- **Counting Instances** - Track the number of objects created.
- **Shared Configuration** - Store settings that should be common across all instances.
- **Utility Functions** - Group utility functions within a class, especially if they logically belong to the class but don’t require an instance (like a mathematical helper function in a class).

## Templates

### Template Functions

- Template functions are functions that are defined with a type parameter, allowing them to operate with any data type.

```cpp
template <typename T>
T multiply(T a, T b) {
    return a * b;
}

/// code

int intResult = multiply(2, 3);         // T is int
double doubleResult = multiply(2.5, 4.2); // T is double

```

### Multiple Template Parameters

- You can use more than one template parameter by specifying them in a comma-separated list.

```cpp
template <typename T, typename U>
void printPair(T a, U b) {
    std::cout << "First: " << a << ", Second: " << b << std::endl;
}

//code

printPair(10, 20.5);      // T is int, U is double
printPair("Hello", 42);   // T is const char*, U is int
```

### Non-Object Type Parameters

- Templates can take non-type parameters, such as integer values or pointers, which must be compile-time constants.

```cpp
template <typename T, int size>
class Array {
private:
    T arr[size];
public:
    int getSize() { return size; }
};

// code

Array<int, 5> intArray;
std::cout << intArray.getSize(); // Outputs 5
```

### Template Functions FULL and PARTIAL Specialization

- **Full specialization** is when you provide a specific implementation for a specific type.

```cpp
template <>
int multiply<int>(int a, int b) {
    std::cout << "Specialized version for int" << std::endl;
    return a * b;
}
```

- **Partial specialization** applies to class templates and allows specialization for a subset of the template parameters.

```cpp
template <typename T, typename U>
class Pair {
    // Generic implementation
};

template <typename T>
class Pair<T, int> {
    // Specialization when the second type is int
};
```

### Variadic Arguments and Variadic Functions

- Variadic templates allow you to create templates that take a variable number of template parameters.

```cpp
template <typename T, typename... Args>
void printAll(T first, Args... args) {
    std::cout << first << " ";
    if constexpr (sizeof...(args) > 0) {
        printAll(args...); // Recursively calls with remaining arguments
    }
}
// USAGE:

printAll(1, 2.5, "Hello", 'C'); // Prints: 1 2.5 Hello C
```

### Template Classes

```cpp
template <typename T>
class Stack {
private:
    std::vector<T> elements;
public:
    void push(T element) { elements.push_back(element); }
    void pop() { elements.pop_back(); }
    T top() const { return elements.back(); }
};

// USAGE

Stack<int> intStack;
intStack.push(10);
intStack.push(20);
std::cout << intStack.top(); // Outputs 20

Stack<std::string> stringStack;
stringStack.push("Hello");
stringStack.push("World");
std::cout << stringStack.top(); // Outputs "World"
```

## ```**inline**``` Functions

- ```inline``` keyword is used to suggest to the compiler that it should attempt to insert the code of a function directly at the point of the function call, rather than performing the usual function call mechanism (e.g., pushing parameters onto the stack and jumping to the function’s address). This process is called **function inlining**.

### Purpose of Function Inlining

- **Performance Improvement** - Function calls involve overhead (stack operations, jump instructions, etc.). By inlining, the compiler replaces the function call with the actual function code, eliminating the overhead of a call.
- **Optimization** - Inlining small functions that are called frequently can result in faster execution. However, for larger functions, it may increase code size, which can negate the benefits.

```cpp
#include <iostream>

inline int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 4); // Inline function call
    std::cout << result << std::endl;  // Outputs: 7
    return 0;
}
```

## ```**inline**``` Variables

- The ```inline``` keyword can also be used with variables in C++, which was introduced in C++17. When used with variables, the inline keyword allows the definition of variables in header files without violating the **One Definition Rule** \(ODR).

### Purpose of inline Variables

- Before C++17, global variables defined in header files had to be marked as ```extern``` to prevent multiple definitions when included in different translation units. C++17 allows variables to be defined as inline, which means they can be defined in header files, and the linker will ensure that there is only one instance of the variable across multiple translation units.

- This is particularly useful for *constant* or *static variables* that need to be shared across multiple translation units without the need for the extern keyword.

```cpp
// config.h
#ifndef CONFIG_H
#define CONFIG_H

inline int global_value = 10;  // Inline variable

#endif
```

### KeyPoints of inline Variables

1. One Definition Rule (ODR):
    - Normally, defining a non-constant global variable in a header file can cause multiple definitions across different translation units, which would violate the ODR and result in a linker error.
    - By marking the variable as inline, the compiler allows the variable to be defined in multiple translation units, but the linker will ensure only one instance of the variable exists in the program.
2. Use with Constant Data:
    - inline variables are most commonly used with constants or static data. They can also be used for variables that have a default value but should not be redefined in every translation unit.
3. Static vs. Inline:
    - Before C++17, static was used for similar purposes (to limit the variable's scope to a single translation unit). The main difference is that static variables are only visible within the translation unit they are defined, whereas inline variables can be shared across translation units but still guarantee only one definition.
4. Thread-Local Variables:
    - inline variables can be used with the thread_local storage class, allowing each thread to have its own instance of the variable.

### Example and Restrictions for inline Variables

```cpp
// config.h
#ifndef CONFIG_H
#define CONFIG_H

inline int global_value = 42;  // Inline variable

#endif

// file1.cpp
#include "config.h"
#include <iostream>

void print_value() {
    std::cout << "File1 value: " << global_value << std::endl;
}

// file2.cpp
#include "config.h"
#include <iostream>

void print_value() {
    std::cout << "File2 value: " << global_value << std::endl;
}

// main.cpp
#include "config.h"

extern void print_value();

int main() {
    print_value();  // File1 value: 42
    return 0;
}
```

- **Non-constant inline variables** - While ```inline``` variables are allowed for variables that are not ```const```, this is mostly useful when you want a variable to have a shared definition across multiple translation units, such as in a singleton pattern or shared configuration. However, these variables should still adhere to the ODR.
